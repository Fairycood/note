# js简介

## js的问世

* 在js问世之前，表单数据的验证只能在服务端进行。js使得在客户端也能完成一些基本的验证任务。
* 如今已经能处理复杂的计算和交互。
* js是客户端语言
* javascript包括三大部分，ECMAScript,DOM，BOM

## ECMAScript

* 两个公司的两个版本的javascript语言备受业界关注，ECMA协会制定了一个名为ECMAScript的标准。
* ECMA定义的只是这门语言的基础，在此基础上可以构建更加完善的脚本语言。
* web浏览器只是ECMAScript实现的宿主环境之一，宿主环境提供基本的ECMAScript的实现，同时也会提供扩展，例如DOM，其他的宿主环境还有(node)
* ECMA标准没有参照浏览器，而是规定了语言的语法，类型，语句，关键字，保留字，操作符，对象。
* ECMAScript就是对实现了该标准的规定的各个方面内容的语言的描述(javascript和ActionScript都实现了该标准)
* ECMAScript的前两个版本没有很多重要的变化，第三个版本才是一次真正意义上的修改涉及到了很多内容，因此第三版标志着ECMAScript成为了一门真正的编程语言
* 2009年发布了ECMAScript的第五个版本。

### ECMAScript兼容

* 规定了要想成为ECMAScript，有哪些必须要遵从，有哪些可以进行扩展。
* 为开发人员基于ECMAScript的开发一门新语言提供的广阔的空间和极大的灵活性。

## 主流浏览器

* IE，FireFox，Safari,Chrome,Opera

# 浏览器历史

1993 Mosaic是互联网历史上第一个获得普遍使用的浏览器
1996 javascript问世
浏览器组成部分
    1.shell外壳
    2.内核
      渲染引擎
      js引擎
      其他模块
2001 ie6实现对js引擎的优化和分离
2008 Google 更加优化

编译语言： 先通篇翻译之后，执行翻译完的文件。
     c c++   速度快 用于底层实现，游戏     移植性不好 

解释语言： 看一行翻译一行执行一行（不需要生成别的文件）
     php js   速度稍微慢一点 稳定性极高    跨平台（极大的优点）

java 先编译后解释 因为java虚拟机的存在
    .java ----java c --编译--.class--jvm(虚拟机)--解释执行

js特点
    1.解释语言
    2.单线程（论转时间片，类似于吃饭）
    3.ECMA标准 js原生也称为ECMAScript
        js三大阶段：ECMAScript + DOM + BOM（后两个由浏览器提供）

# 运算符

运算符主要还是看运算的结果，运算过程中产生的数值是附属品

赋值的顺序从右到左，计算的顺序从左到右。  ()的计算优先级最高
赋值表达式有**返回值**

```js
console.log(a = 200) //200
// b = (a = 200) 个人理解，可以把上面的赋值表达式理解为下面这种，既然是个表达式。那么就有值，使用b来接受这个值
console.log(b) //200
```

## 逻辑运算符

只有 undefined null NaN "" 0 false 这六个字符转化为布尔值类型为false

* && 先看第一个表达式转化为布尔值的结果，如果结果为真，那么就看它第二个表达式转化为布尔值的结果。如果只有两个表达式的话。只看到第二个表达式就可以返回该表达式的值了。

* || 如果第一个表达式转化为布尔值的结果为true，那么直接输出第一个表达式的值。

  短路语句(if的简写形式)
  2 > 1 && document.write('xujie');

  if(2 > 1) {
    document.write('xujie)
  }

  ||经常在兼容里用到。返回一个能用的。

|| 运算符碰到表达式转化为布尔值为true时就输出该表达式。直到最后一个表达式无论真假都输出。(！！！短路操作符)
&& 运算符碰到表达式转化为布尔值为false时就输出该表达式。直到最后一个表达式无论真假都输出。(短路操作符，如果使用的两个变量，第一个运算值为false的话，哪怕第二个变量没有定义，也不会报错，因为没有必要计算下一个值了，(短路操作符！！！))

! 非
    把表达式转化为布尔值在取反
    ！！ 把表达式转化为布尔值在取反后再取反，相当于表达式转换为布尔值,和Boolean()函数作用一样。

## 乘性运算符

* *乘法

1. infinity与0相乘是NAN
2. infinity与非0相乘是infinity

*  / 除法

1. infinity被infinity除是NAN
2. 0被0除是NAN
3. 1 / 0 为infinity

* 求模 %

1. 被除数无限大而除数有限大 结果为NAN
2. 被除数为有限大，而除数为0  结果为NAN
3. infinity % infinity 结果为 NAN

## 加性运算符

1. + 加法

* 如果都是数字的话，会有一个隐式的Number()运算
* 加法中如果两边有一个是字符串就要把另一个转化为字符串进行拼接。 "1" + true = "1true"  "1" + undefined = "1undefined"
* 如果有一方是对象，函数,数组就调用toString()方法之后进行拼接(因为复杂数据类型在隐式转化的时候会调用toString方法)

1. 减法-

* 会有一个隐式的Number()的运算
* NAN和任何数字的运算都会得到NAN 1 - "a"返回NAN

## 关系运算符 > < >= <=

* 如果有一方是数字的话，会有一个隐式的Number()的运算
* 字符串进行比较时单个的字符按照asc码值来对比大小 "10" > "8"  false  先比较比较"1" 和"8"，如果第一位大小一样在向下比较
* NAN和任何数据相比较都是false

## == 和 ！=

* 隐式的调用Number()进行转换
* NAN不等于任何，包括自身
* undefined == null
* undefined和null不会转换成任何值，任何一个数和这两个相比，都不大于等于和小于
* 对象(引用值数据)相比较，比较的是地址。

## =和！

1. 不会发生类型转换，是比较两个数值在不发生类型转换的条件下相等或者不等(不仅要数值相等，还要类型相等)
2. undefined ！== null

## 逗号运算符

* 使用逗号运算符可以在一条语句执行多个操作，例如 var a = 1,b = 2, c = 3;(每一个变量都是相当于有var声明过的)，(但是var a = b = 123;a声明过，b没有声明过)
* 用于返回表达式中的最后一项 var num = (1,2,3,4); 那么num的值为4，因为他是最后一项

# 语句

## if

* if语句中的条件可以是任意的表达式，系统会自动的调用Boolean()函数来把表达式的结果转换为布尔值

## do-while

* 后测试循环语句

## while

* 前测试循环语句

## for

* 由于ECMAScript中没有块级作用域的概念，所以在循环内部定义的变量，在外部也可以被访问到。

## for-in

* 是一种精准的迭代语句，用于枚举对象中的属性。
* 要迭代的对象的变量值为undefined和null时，for-in语句会抛出错误。

## label

* 为代码添加标签，通常都要配合循环和break，continue来使用。

## break，continue

* break 立刻退出循环，强制执行循环后面的语句
* continue 立刻退出当前循后从循环的顶部继续执行

## with

* with语句可以将代码的作用域设置到一个特定的对象中，在严格模式禁用

## switch语句

### js是弱处理性语言

1. case里的数据类型完全可以不一样（和其他强类型语言不一样）
2. break 循环终止 必须写在循环里面
3. continue 终止本次循环，开始下一次的循环
4. switch语句在比较时，使用的是全等操作符，不会发生类型转换。
   switch(n){
    case "n1":
        console.log("");
        break;
    case "n2":
        console.log("");
        break;
    case "n3":
        console.log("");
        break;

}

# Javascript的基本语法

## Javascript是区分大小写的语言

## 标识符

* 标识符的命名规则：

1. 变量只能以字母 _ $ 开头
2. 变量内部可以使用数字
3. 关键字，和保留字不能使用
4. 按照惯例采用小驼峰(第一个字母小写，后面的开头大写)的格式

* 其他的命名规则

1. 事件类型全部小写
2. 构造函数首字母要大写
3. 非构造函数以小写字母开头

## 变量

* javascript中的变量是松散类型的，松散类型就是能保存任何类型的数据。
* 可以在修改变量的值的同时修改变量的类型，但是不太推荐。
* var 申请多条变量，使用逗号隔开。 var a = 0,b = 0;

# 数据类型

### 原始值和引用值

* 原始值： number Boolean String undefined（未定义，未赋值） null（占位置，空值）
* stack 栈 先进去的后出来 拷贝时拷贝的是数值
* 栈数据 不可更改，复制时直接找一个新的地址放入新的值

* 引用值： arr object function
* 栈里面存的是地址(指向堆)   堆里面存的才是真正的对象的数据
* heap 堆   复制时，开辟一个新的栈空间，新的栈空间里面放的是对象在堆上的地址。

引用值比较比较的是地址:    {} == {} //false
原始值比较的是数值(有隐式类型转换);    var a = 1; var b = true;
                                    a == b //true
                                    a === b  //false
    == 只比较值   ===不仅比较值，还比较数据类型

```javascript
  var arr1 = [100];
  var arr2 = arr1;
  arr1=[100,80];
  console.log(arr2);//[100] 因为现在是直接建立了一个新的arr1覆盖了原来的arr1

  var arr1 = [100];
  var arr2 = arr1;
  arr1.push(80);
  console.log(arr2);//[100,80] 因为数组是引用值，arr1和arr2公用一个堆内存
```

### javascript的数据类型

* 五个基本数据类型：number Boolean String undefined（未定义，未赋值） null（占位置，空值）
* 复杂数据类型: object(数组，函数，对象)
* javascript中所有的值都是上述六种数据类型之一
* js天生是浮点型
* js是动态类型语言

#### undefined

* 使用var声明然后未初始化的变量值就是undefined，
* undefined的主要作用就是为了比较，引入这个值是为了正式区别空对象指针(null)和未经初始化的变量。
* 只有一种情况下变量不定义就使用不会报错，那就是使用typeof()时，并且返回字符串类型的undefined.所以变量在定义之后立刻初始化，这样在使用typeof返回undefined时，就可以很肯定的知道是没有定义而不是没有初始化。

#### null（空对象指针）

* typeof(null) 是object 历史遗留问题
* 如果一个变量准备将来用于保存对象，那么最好将该变量初始化为null而不是其他数值。然后直接将该变量与null比较就可以知道，变量目前有没有被赋值为一个对象
* 实际上undefined是派生自null的。所以undefined == null

#### boolean

* 转换值为false的数据 false "" 0 NAN undefined null

#### Number

* 八进制以0开头，十六进制以0x开头。

##### 浮点数

* 浮点数值的计算很不精确(不只是js这样，所有使用了IEEE754标准的语言都是这样)，而且浮点数值占用的的存储空间比较大。引擎会合理的把一些浮点数值转化为整数值。

##### 数值范围

* js中数值有一个最大和最小的区间。infinity就是正无穷。
* 使用isFinite()函数来判断是否介于最大数值和最小数值区间内。
* 超过范围的数值将无法参加下一次计算

##### NAN

* 非数，用于表示本来要返回数值的操作数并没有返回数值的情况(这样就不会抛出错误了)
* NAN与任何数都不相等，包括自身
* 任何涉及到NAN的操作都会返回NAN
* isNAN()方法，用于判断数值是否为NAN类型，使用isNAN()方法时，会隐式的调用number()方法

##### 数值转换

* Number()
* parseInt()
* parseFloat()

#### string

1. 字符串有转义字符
2. ECMAScript中的字符串是不可变的，要想改变字符串的值就要销毁原来的字符串，然后再用另一个新的字符串填充变量。
3. toString()方法，undefined和null没有这个方法
4. String()任何数值类型的数据都能够转化为字符串

#### object

* ECMAScript中的对象就是一组数据和功能的集合，可以通过new操作符来创建
* Object()类型是所有他的实例的基础
* 由于ECMAScript并不定义DOM，BOM所以他们可能不会继承自Object()

## typeof

* 因为ECMAScript是松散的，所以需要一种鉴定手段来测定变量的数据类型

### typeof返回的类型

* number string boolean object undefined function (都是返回字符串形式的结果)
* 泛泛的引用数据值（数组，对象，null）都会被称为object
* 函数在ECMAScript中是对象，而不是一种数据类型，但是函数确实拥有一些特殊的属性，因此使用typeof来区分函数和其他对象也是非常有必要的。

## instanceof（检测引用类型的值）

* typeof在检测引用类型值得时候用处并不大
* 原型链的时候再来总结

## 执行代码时遇到错误

1. （低级错误）语法错误代码一行也不会执行
2. 逻辑错误（标准错误）后续代码不会执行

* 无论哪种错误都不会影响到其他代码块的执行

# 类型转换

## 显示类型转换

### Number()可以用于任何类型

 Number（） 可以把数据转换为数字类型   例如字母a(虽然类型变为了number但是数据值为NAN)  重点在于把数据给转换为数字
 Number（）没有砍断原则

 

|       原数据类型        | 123  | "123" | "12345a" | "a"  | true |
| :---------------------: | ---- | ----- | -------- | ---- | ---- |
| Number()z转换之后的结果 | 123  | 123   | NAN      | NAN  | 1    |

| null | undefined | [123] | [123,2334] | ""   | []   |
| :--: | --------- | ----- | ---------- | ---- | ---- |
|  0   | NAN       | 123   | NAN        | 0    | 0    |

此外obj，function，NAN，undefined 转化完之后都是NAN

复杂类型隐式转化：

1. 先用valueOf()方法获取其原始值。如果原始值不是Number类型，则使用toString()转换成String。
2. 再将String转换为number运算。

**字符串的number()转化** 

1. 如果只包含数字，那么转化为10进制数值，会忽略前导零。
2. 字符串中包含有效的浮点格式，就转化为浮点数
3. 如果是十六进制，就转化为10进制
4. 如果字符串是空的就转化为零。
5. 其他格式全部转化为NAN

### parseInt(string，radix)用于把字符串转化为整形数值

1. parseInt()转换时，更多的是看是否符合数值模式，会忽略字符串前面的空格，直至找到第一个非空格字符
2. 如果第一个不是数字字符或者负号，就会返回NAN。比如""空字符串返回NAN，22.5返回22因为.不是有效数字字符
3. parseInt()有一个 砍断原则 从数据首位开始看一直到非数字类型截止 例如100px 转换之后变成100
4. 不指定进制的话，意味着让引擎自己决定按照哪种进制解析字符串，所以无论什么情况都要指定进制 (基底是0的话，有的浏览器会直接输出原始值，或者NAN。如果出现了不属于该进制的输的话，输出NAN。 例如：以二进制为基底的8)

### parseFloat(string)用于把字符串转化为浮点数值

1. parseFloat(string)返回一个浮点数。有一个 砍断原则 从数据首位开始看一直到非数字类型截止
2. 只会识别一个小数点，22.45.21返回22.45

### string()

* string（par）把数据类型转换为字符串类型

### toString()

* par.toString() !!! undefined 和 null 不能用toString() 
* num.toString(redix) 把num转换为redix进制的数字

### Boolean()

Boolean（）除了那六种数据其他都转换为true 只有 undefended null NaN "" 0 false 这六个字符转化为布尔值类型为false

## 隐式类型转换

1. isNAN("num") 包含一个隐含的过程 先进行Number(num)操作然后再 isNAN(Number(num));

2. ++/--(自增自减运算符)    +/-(一元正负) 都会调用Number()
   -*/% 都会调用Number（）

3. && || 与或在决定返回值时是看表达式的布尔值为真或者为假 逻辑非 !(转换为布尔类型，在取反) 

4. < > <= >= 有数字相比较的就会隐式转换为数字

5. + 当加号两端有一个string类型数字时，就会调用String()

6. == != 有隐式类型转换

7. 不发生类型转换的 ===  !==

隐式转换规则：
1.转成String类型。  + (字符串连接符)
2.转成number类型。  ++/--(自增自减运算符) + - * / %(算数运算符) > < >= <= == != (关系运算符)
3.转化为布尔类型。 ！(逻辑非运算符)
4.不发生类型转换。 ===  !==

## 对象的隐式类型转换

！！！复杂数据类型会先隐式转换为String ，然后在转变为Number。
复杂类型隐式转化：
1.先用valueOf()方法获取其原始值。如果原始值不是Number类型，则使用toString()转换成String。
2.再将String转换为number运算。

！！！！空数组的toString()方法会得到空字符串。
！！！！空对象的toString()方法会得到字符串[object,Object]

[] == 0    //true
[].valueOf().toString()得到空字符串
Number("") == 0 成立

![] == 0  //true
逻辑非，先把表达式转换为布尔值在取反。[]不在那六种转换完为假的数据类型中。所以转换后为false
Number(false) == 0 成立

[] == ![]  //true
[].valueOf().toString()得到空字符串
逻辑非，先把表达式转换为布尔值在取反。[]不在那六种转换完为假的数据类型中。所以转换后为false
Number("") == Number(false)  成立

{} == !{}  //false
{}.valueOf().toString()得到字符串[object,Object]
!{}先把表达式转换为布尔值在取反。{}不在那六种转换完为假的数据类型中。所以转换后为false
Number([object,Object]) == Number(false)  不成立

[] == [] //false
{} == {} //false
引用数据存储在堆里，比较的是地址。所以不成立。

# 函数

## 弱数据语言永远都不可能输出地址。只会输出地址指向的房间。不像c语言一样会输出指针，指针里面是地址

console.log(test)的话，打印的是函数的方法体，不是地址
不要在if语句里面使用函数声明

### 函数声明

function test() {

}
test();

### 函数表达式

var test = function abc(){
    ...
}
等号后面是表达式 所以说abc不起作用。和匿名函数差不多

1. 命名函数表达式
   var test = function abc(){
    ...
   }
2. 匿名函数表达式---函数表达式
   var test = function (){
    ...
   }

#### 函数中所有的参数传递的都是值，不可能通过引用来传递参数

1. 基本类型的值传递给函数，就和复制时一样，函数的arguments新开一个栈内存，拷贝过来外面变量的值，arguments中变量的值和外面的变量指向不是同一个栈地址，函数内部修改arguments的值，不会影响外面的变量。
2. 引用类型数值当做参数传递给函数时，也和复制一样，函数的argument新开一个栈内存存储外面引用值变量的地址。在函数内部修改参数时，外面的变量也会跟着变化，arguments中的变量和外面的变量指向的不是同一个栈地址，但是都指向同一个堆上的数据。可是要是为参数重新赋值一个引用类型值的话，外面的变量还是不受影响，因为根本就不是一个栈内存。
3. 函数的参数就是一个局部变量，函数执行完就销毁了。传参的过程就是一个拷贝的过程。
4. function(a,b){} 隐式的在函数里var a，var b
5. 函数也是对象，栈内存存地址，堆内存存数据

* 未指定函数返回值的函数返回的是undefined

## 不定参

* 函数不定参，定义的函数和调用函数时参数数量不一样的话，解析器不会有任何怨言。
* 因为函数接收到的参数是通过一个arguments数组进行表示的。arguments[]用于接收实参列表。函数名.length 表示形参的长度。arguments.length 表示实参的长度
* 函数内的形参和实参列表(arguments)有一种映射关系，他们两个都会跟着对方变，但是并不是说他们两个具有相同的内存空间，内存空间是独立的，但是值会同步。不推荐使用arguments[]来修改函数内部的实参，代码可读性太差。
* 实参列表(arguments)出生时有几个就是几个。如果函数调用时传入的实参就比形参少，函数内再去给arguments列表内缺少的形参赋值。arguments[]不会再跟着变了。

## 没有重载

* js不向java一样，可以进行函数的重载。但是可以通过不定参来实现类似重载的效果。

## 递归

* 针对于那些特别容易找出规律的功能。
* 最典型的是求阶乘和菲什么数列
* 使用递归时，尽量使用argument.callee

# 一些零散的知识点

## js是弱处理性语言

1. case里的数据类型完全可以不一样（和其他强类型语言不一样）
2. 数组内的数据类型可以是完全不同的数据类型 var arr=[1,2,"abd",undefined]

## Javascript的垃圾回收

* javascript会进行自动的内存回收，所以不必关心内存管理问题
* 标记清除法，常用策略。
* 引用计数法，有很大的问题，其中常见的为循环引用。导致该策略性能较低

* js的字符串也是基于数组的，可以通过下标取数值(也可以通过str.charAt(i)来取值)。也有length属性

# 严格模式



## "use strict" ;语句来激活严格模式   就是一行字符串，不会对不兼容严格模式的浏览器产生影响。

* 不再兼容 es3 的一些不规则语法。使用全新的 es5 规范。两种用法：

1. 全局严格模式
2. 局部函数内严格模式（推荐）

## 严格模式和ES3模式的区别

1. witch(obj){
   改变作用域链的最顶端(将obj作为此代码块的作用域最顶端，通常配合命名空间使用)
   }  //效率会变低很多  es5严格模式禁用

2. arguments.callee  function.caller      //这两个属性es5严格模式禁用

3. 变量赋值前必须声明  

4. var a = b = 3;会报错，b is undefined
5. a = 3;会报错,a is undefined  

6. 局部的this必须被赋值  在es5的严格模式下，预编译下的this不会指向windows为undefined。但是全局的this还是指向window

7. 拒绝重复的属性和参数

8. eval()可以把字符串当做代码执行 禁用

9. 严格模式不支持八进制字面量

# 其他的知识块

## Global对象

* 不属于任何的对象的属性和方法，最终都是它的属性和方法
* 没有办法直接访问Global对象，但是浏览器都是将Global对象当做window对象的一部分加以实现。

## URi解码方法

* encodeURI()主要应用于整个URI，只会把空格替换成编码。对应的解码方法为decodeURI()
* encodeURIComponent()只要应用于某一段，会把所有非标准字符进行编码(冒号，正斜杠...)，对应的解码方法为decodeURIComponent()

## eval()方法

* eval()方法会把字符串当做真正的代码来进行执行
* 在eval()中创建的任何变量和函数都不会被提升，因为他们被包含在一个字符串中只有在解析代码的时候才会识别内容。
* 很强大，很危险。尤其是在指定用户输入的数据情况下，会导致恶意用户输入(代码注入)

## 逗号运算符

* (a,b)会看一眼a，然后返回b

## 命名空间

* 为了解决命名冲突的问题，已经弃用。

## 区别数组和对象的三种方法

1. 用constructor          []的原型里构造函数是Array
       {}的原型里的构造函数是Object
2. 用instanceof           [] instanceof Array true
       {} instanceof Array false
3. 用Object.prototype.toString.call([])    [object Array]
   用Object.prototype.toString.call({})   [object Object]

## jq如何实现链式调用

* 方法的最后return this。

## for in 循环 专门用来遍历对象

```javascript
for(var prop in obj) {
    ...
}

```

* prop是变量存储着属性名，对象的.操作符没办法访问变量，但是([])运算符可以访问变量。所以通常配合obj[prop]的形式来访问对象的值
* 数组的下标不一定非得是数字，也可以是自己定义的字符串，因为数组本身也就是对象。键值对形式的数据集合。var a = []; a["xujie"] = 123;
* 也可以使用for in循环来访问数组，和访问对象一样，变量prop是属性名(在数组中也就是下标)不是属性值。